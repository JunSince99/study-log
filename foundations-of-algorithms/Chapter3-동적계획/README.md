# 동적계획(DP)
동적계획(dynamic programming)은 분할정복과 반대로 바텀업(bottom-up) 접근 방법이다. 

동적계획은 문제의 입력사례를 분할하여 문제를 푼다는 점에서 분할정복과 비슷하지만 분할한 입력사례를 재귀 호출하여 답을 얻는 대신 가장 작은 입력사례의 답을 구해 저장해놓고, 필요하면 꺼내 쓴다. 동적계획의 계획이란 해답을 구하기 위해서 미리 배열(테이블)을 구축하는 것을 뜻한다.

Chapter1의 피보나치 알고리즘이 전형적인 동적계획이다. 피보나치 항을 순서대로 구한 뒤 값을 저장해 놓고 필요할 때마다 배열에 접근해 피보나치 항을 구한다.  
동적계획 알고리즘의 절차는 다음과 같다.
~~~
1. 문제의 입력사례에 대해서 해답을 계산하는 재귀 관계식을 세운다.
2. 작은 입력사례부터 먼저 해결하는 상향식 방법으로 전체 입력사례에 대한 해답을 구한다.
~~~
## 3.1 이항계수 구하기
이항계수란 n에서 뽑은 k개의 순서 없는 조합의 가짓수이다.

$$
\begin{aligned}
\binom{n}{k} = \frac{n!}{k!(n-k)!},\quad 0 \le k \le n
\end{aligned}
$$
이 식의 경우 바로 알고리즘에 적용하기는 어렵다. n! 값이 기하급수적으로 커지기 때문이다.  
다음과 같은 수식을 이용하면 $n!$ 이나 $k!$ 값을 구하지 않고도 이항계수를 구할 수 있다.
$$
\binom{n}{k} =
\begin{cases}
\binom{n-1}{k-1}+\binom{n-1}{k}, & 0 < k < n, \\
\quad \quad \ \ \ 1\quad \quad \ \ ,  & k=0\quad 또는\quad k=n
\end{cases}
$$

~~~cpp
int bin (int n, int k)
{
    if (k == 0 || n == k)
        return 1;
    else
        return bin(n-1, k-1) + bin(n-1, k);
}
~~~
하지만 이 코드의 경우, 예를들어 bin(n-1, k-1), bin(n-1, k) 둘 모두 bin(n-2, k-1)이 필요하고 각각 재귀로 중복 연산하는 것을 알 수 있다. 따라서 동적계획으로 이전 값들을 저장하며 연산하는 알고리즘이 필요하다. 배열 $B[i][j]$에 $\binom{i}{j}$ 값을 저장하며 계산해보자.
~~~cpp
int bin2(int n, int k)
{
    index i, j;
    int B[0~n][0~k];

    for(i = 0; i <= n; i++) {
        for(j = 0; j <= min(i, k); j++) {
            if (j == 0 || j == i)
                B[i][j] = 1;
            else
                B[i][j] = B[i-1][j-1] + B[i-1][j];
        }
    }
    return B[n][k];
}
~~~
위의 함수는 $O(nk)$의 시간복잡도를 가지고 있다.
최종값을 위해서는 바로 전 행만 필요하므로 0~k의 크기를 가진 배열 하나로도 표현할 수 있다.
## 3.2 프로이드의 최단경로 알고리즘
![](./images/graph.jpg)
위 그림은 가중치 포함 방향그래프이다.

그림에서 원은 정점(vertex), 선은 간선(edge)이라고 한다. 방향이 있는 그래프를 방향그래프라고 하고 edge에 있는 숫자는 해당 방향의 가중치이다. 일반적으로 가중치는 해당 경로의 거리나 소요시간, 비용 등을 의미한다. 특정 vertex에서 같은 vertex로 돌아오는 경로를 순환 경로(cycle)라고 하고, 그래프에 순환경로가 있으면 순환적(cyclic), 없으면 비순환적(acyclie)이라고 한다. 같은 정점을 두번 거치지 않는 경로를 단순경로(simple path)라고 한다.
## 3.3 동적계획과 최적화 문제
## 3.4 연쇄 행렬곱셈
## 3.5 최적 이분검색트리
## 3.6 외판원 문제
## 3.7 DNA 서열 정렬