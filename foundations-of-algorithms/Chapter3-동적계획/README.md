# 동적계획(DP)
동적계획(dynamic programming)은 분할정복과 반대로 바텀업(bottom-up) 접근 방법이다. 

동적계획은 문제의 입력사례를 분할하여 문제를 푼다는 점에서 분할정복과 비슷하지만 분할한 입력사례를 재귀 호출하여 답을 얻는 대신 가장 작은 입력사례의 답을 구해 저장해놓고, 필요하면 꺼내 쓴다. 동적계획의 계획이란 해답을 구하기 위해서 미리 배열(테이블)을 구축하는 것을 뜻한다.

Chapter1의 피보나치 알고리즘이 전형적인 동적계획이다. 피보나치 항을 순서대로 구한 뒤 값을 저장해 놓고 필요할 때마다 배열에 접근해 피보나치 항을 구한다.  
동적계획 알고리즘의 절차는 다음과 같다.
~~~
1. 문제의 입력사례에 대해서 해답을 계산하는 재귀 관계식을 세운다.
2. 작은 입력사례부터 먼저 해결하는 상향식 방법으로 전체 입력사례에 대한 해답을 구한다.
~~~
## 3.1 이항계수 구하기
이항계수란 n에서 뽑은 k개의 순서 없는 조합의 가짓수이다.

$$
\begin{aligned}
\binom{n}{k} = \frac{n!}{k!(n-k)!},\quad 0 \le k \le n
\end{aligned}
$$
이 식의 경우 바로 알고리즘에 적용하기는 어렵다. n! 값이 기하급수적으로 커지기 때문이다.  
다음과 같은 수식을 이용하면 $n!$ 이나 $k!$ 값을 구하지 않고도 이항계수를 구할 수 있다.
$$
\binom{n}{k} =
\begin{cases}
\binom{n-1}{k-1}+\binom{n-1}{k}, & 0 < k < n, \\
\quad \quad \:\:\:1\quad \quad \:\:,  & k=0\quad 또는\quad k=n
\end{cases}
$$

~~~cpp
int bin (int n, int k)
{
    if (k == 0 || n == k)
        return 1;
    else
        return bin(n-1, k-1) + bin(n-1, k);
}
~~~
하지만 이 코드의 경우, 예를들어 bin(n-1, k-1), bin(n-1, k) 둘 모두 bin(n-2, k-1)이 필요하고 각각 재귀로 중복 연산하는 것을 알 수 있다. 따라서 동적계획으로 이전 값들을 저장하며 연산하는 알고리즘이 필요하다. 배열 B[$i$][$j$]에 $\binom{i}{j}$ 값을 저장하며 계산해보자.
~~~cpp
int bin2(int n, int k)
{
    index i, j;
    int B[0~n][0~k];

    for(i = 0; i <= n; i++) {
        
    }
}
~~~
## 3.2 프로이드의 최단경로 알고리즘
## 3.3 동적계획과 최적화 문제
## 3.4 연쇄 행렬곱셈
## 3.5 최적 이분검색트리
## 3.6 외판원 문제
## 3.7 DNA 서열 정렬