# 알고리즘 : 효율, 분석, 차수
## 1.1 알고리즘
이 책은 특정 언어가 아닌 알고리즘 기법을 배우는 책이다.

특정한 문제를 어떤 알고리즘으로 풀지, 해당 알고리즘이 시간과 공간의 사용량을 기준으로 얼마나 효율적인지를 분석하는데 관심을 가져야한다.

그렇기 때문에 모든 알고리즘은 C++을 기반으로한 **의사코드(pseudocode)** 로 표현한다.

의사코드의 예
~~~cpp
number sum (int n, const number S[])
{
    index i;
    number result;

    result = 0;
    i=1~n까지 반복:
        result = result + S[i];
    return result;
}
~~~
위와 같이 c++의 정확한 문법보다는 사람이 쉽게 이해하는 것에 초점을 두고 작성하는 것이 의사코드이다. 실제로 동작하진 않는다.
### 1.2 효율적인 알고리즘 개발의 중요성
같은 문제에대한 두 개의 알고리즘을 비교해보면 알고리즘의 효율성이 왜 중요한지 알 수 있다.
### 1.2.1 순차검색 vs 이분검색
(정렬된 리스트)  
순차검색 : 찾고자 하는 원소가 나올 때까지 첫번째 요소부터 끝까지 하나하나 탐색하는 방법.  
이분검색 : 반 씩 잘라서 탐색
~~~cpp
(이분검색 의사코드)
void binsearch(int n, const keytype S[], keytype x, index& location)
{
    index low, high, mid;

    low = 1; high = n;
    location = 0;
    while (low <= high && location == 0) {
        mid = 내림((low + high)/2);
        if (x == S[mid])
            location = mid; // 위치 반환
        else if (x < S[mid])
            high = mid -1; // low~high 범위를 mid 이전으로
        else
            low = mid + 1; // low~high 범위를 mid 이후로
    }
}
~~~
|배열의 크기|순차검색 횟수|이분검색 횟수|
|---|---|---|
|128|128|8|
|1,024|1,024|11|
|1,048,576|1,048,576|21|
|4,294,967,296|4,294,967,296|33|  

위의 표로 알 수 있듯이 알고리즘에 따라 효율성이 굉장히 크게 차이날 수 있다.  
하지만 40억 번의 검색 횟수도 컴퓨터의 발전으로 몇 초 정도 밖에 걸리지 않아 알고리즘의 중요성이 크게 부각되지 않을 수 있다. 이번에는 피보나치 수열의 경우를 살펴보자.
### 1.2.2 피보나치 수열
피보나치 수열은 다음과 같이 정의된다.
<div align="center">

$$
f_0 = 0\\
f_1 = 1\\
f_n = f_{n-1} + f_{n-2}
$$

</div>
피보나치 수열을 간단히 재귀로 구현하면

~~~cpp
int fib (int n)
{
    if (n <= 1)
        return n;
    else
        return fib(n-1) + fib(n-2);
}
~~~

## 1.3 알고리즘의 분석
### 1.3.1 시간복잡도 분석
### 1.3.2 이론의 적용
### 1.3.3 정확성 분석
## 1.4 차수
### 1.4.1 차수의 직관적인 소개
### 1.4.2 차수의 정식 소개
### 1.4.3 극한을 사용하여 차수를 결정하기
## 1.5 이 책의 개요